<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lunar Calendar</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Frank+Ruhl+Libre:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        /* ========================================
           DESIGN SYSTEM - Dieter Rams Aesthetic
           ======================================== */

        :root {
            /* Type Scale (1.25 ratio) */
            --text-xs: 10px;
            --text-sm: 12px;
            --text-base: 14px;
            --text-lg: 18px;
            --text-xl: 24px;
            --text-2xl: 32px;
            --text-3xl: 48px;
            --text-4xl: 72px;

            /* Letter Spacing */
            --tracking-tight: -0.02em;
            --tracking-normal: 0;
            --tracking-wide: 0.1em;
            --tracking-wider: 0.2em;

            /* Colors */
            --white-100: rgba(255,255,255,0.95);
            --white-80: rgba(255,255,255,0.8);
            --white-60: rgba(255,255,255,0.6);
            --white-40: rgba(255,255,255,0.4);
            --white-20: rgba(255,255,255,0.2);
            --accent-warm: rgba(255,220,180,0.7);

            /* Spacing */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 40px;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0a0a12;
            font-family: 'Helvetica Neue', -apple-system, sans-serif;
            font-weight: 400;
            -webkit-font-smoothing: antialiased;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Base Label */
        .label {
            position: fixed;
            z-index: 100;
            color: var(--white-80);
            pointer-events: none;
        }

        /* ========================================
           CURRENT TIME - Top center
           ======================================== */
        .current-time {
            position: fixed;
            top: var(--space-lg);
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
        }

        .time-display {
            font-size: var(--text-3xl);
            font-weight: 300;
            color: var(--white-60);
            letter-spacing: var(--tracking-wide);
            font-variant-numeric: tabular-nums;
        }

        .time-location {
            display: none;
        }

        /* ========================================
           HEBREW DATE - Top left corner
           ======================================== */
        .hebrew-date {
            position: fixed;
            top: 60px;
            left: var(--space-xl);
            text-align: left;
            z-index: 100;
            pointer-events: none;
        }

        .hebrew-date-hebrew {
            font-family: 'Frank Ruhl Libre', 'Times New Roman', serif;
            font-size: var(--text-base);
            font-weight: 400;
            color: var(--white-40);
            letter-spacing: 0.02em;
            direction: rtl;
        }

        .hebrew-date-phonetic {
            font-size: var(--text-xs);
            font-weight: 400;
            color: var(--white-20);
            letter-spacing: var(--tracking-wide);
            margin-top: 2px;
            text-transform: uppercase;
        }

        /* Month Theme - Hidden */
        .month-theme {
            display: none;
        }

        /* ========================================
           LUNAR PHASE - Below moon
           ======================================== */
        .lunar-phase {
            position: fixed;
            top: 72%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
            line-height: 1.6;
        }

        .lunar-dots {
            display: none;
        }

        .lunar-day {
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--white-40);
            letter-spacing: var(--tracking-wide);
            text-transform: uppercase;
        }

        .lunar-meaning {
            font-size: var(--text-lg);
            font-weight: 500;
            letter-spacing: var(--tracking-wide);
            text-transform: uppercase;
            color: var(--white-80);
            margin-top: var(--space-sm);
        }

        .lunar-sefirah {
            font-size: var(--text-sm);
            font-weight: 400;
            letter-spacing: var(--tracking-normal);
            color: var(--white-40);
            margin-top: var(--space-sm);
            font-style: italic;
        }

        /* ========================================
           TEMPERATURE - Bottom left
           ======================================== */
        .temp {
            bottom: var(--space-xl);
            left: var(--space-xl);
            font-size: 64px;
            font-weight: 400;
            letter-spacing: var(--tracking-tight);
            line-height: 1;
            color: var(--white-100);
        }

        .feels {
            bottom: 52px;
            left: 140px;
            font-size: var(--text-base);
            font-weight: 400;
            color: var(--white-60);
        }

        /* ========================================
           WIND - Bottom right
           ======================================== */
        .wind {
            bottom: var(--space-xl);
            right: var(--space-xl);
            text-align: right;
        }

        .wind-speed {
            font-size: var(--text-xl);
            font-weight: 300;
            color: var(--white-80);
        }

        .wind-dir {
            font-size: var(--text-xs);
            font-weight: 500;
            color: var(--white-40);
            letter-spacing: var(--tracking-wider);
            margin-top: var(--space-xs);
        }

        /* ========================================
           ZMANIM PANEL - Bottom right
           ======================================== */
        .zmanim {
            position: fixed;
            bottom: var(--space-xl);
            right: var(--space-xl);
            text-align: right;
            z-index: 100;
            pointer-events: none;
            padding: var(--space-md) var(--space-lg);
            background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 2px;
        }

        .zmanim-label {
            font-size: var(--text-xs);
            font-weight: 500;
            letter-spacing: var(--tracking-wider);
            color: var(--white-40);
            text-transform: uppercase;
        }

        .zmanim-time {
            font-size: var(--text-2xl);
            font-weight: 300;
            color: var(--white-100);
            margin-top: var(--space-sm);
            letter-spacing: var(--tracking-wide);
            font-variant-numeric: tabular-nums;
        }

        .zmanim-greeting {
            font-size: var(--text-xs);
            font-weight: 500;
            color: var(--accent-warm);
            margin-top: var(--space-sm);
            letter-spacing: var(--tracking-wider);
            text-transform: uppercase;
        }

        /* ========================================
           WEATHER INFO - Top corners
           ======================================== */
        .condition {
            top: var(--space-xl);
            left: var(--space-xl);
            font-size: var(--text-xs);
            font-weight: 500;
            letter-spacing: var(--tracking-wider);
            text-transform: uppercase;
            color: var(--white-40);
        }

        .atmosphere {
            top: var(--space-xl);
            right: var(--space-xl);
            text-align: right;
            font-size: var(--text-sm);
            font-weight: 400;
            color: var(--white-40);
            letter-spacing: var(--tracking-normal);
        }

        .atmosphere span {
            margin-left: var(--space-md);
        }

        /* ========================================
           OMER COUNTER
           ======================================== */
        .omer-count {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .omer-count.visible {
            opacity: 1;
        }

        .omer-number {
            font-size: var(--text-sm);
            font-weight: 400;
            color: var(--white-40);
            letter-spacing: var(--tracking-wide);
        }

        .omer-sefirot {
            font-size: var(--text-xs);
            font-weight: 400;
            letter-spacing: var(--tracking-wide);
            color: var(--white-40);
            margin-top: var(--space-xs);
        }

        /* ========================================
           PARSHA - Bottom left above temp
           ======================================== */
        .parsha {
            position: fixed;
            bottom: 120px;
            left: var(--space-xl);
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .parsha.visible {
            opacity: 1;
        }

        .parsha-label {
            font-size: var(--text-xs);
            font-weight: 500;
            letter-spacing: var(--tracking-wider);
            color: var(--white-20);
            text-transform: uppercase;
        }

        .parsha-name {
            font-size: var(--text-base);
            font-weight: 400;
            color: var(--white-60);
            margin-top: var(--space-xs);
        }

        /* ========================================
           CHANUKAH INDICATOR
           ======================================== */
        .chanukah {
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .chanukah.visible {
            opacity: 1;
        }

        .chanukah-text {
            font-size: var(--text-base);
            font-weight: 500;
            letter-spacing: var(--tracking-wide);
            color: var(--accent-warm);
            text-transform: uppercase;
        }

        /* ========================================
           KABBALISTIC QUOTE - Centered on moon
           ======================================== */
        .quote {
            position: fixed;
            top: 42%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 100;
            pointer-events: none;
            max-width: 640px;
            width: 90%;
        }

        .quote-hebrew {
            font-family: 'Frank Ruhl Libre', serif;
            font-size: var(--text-2xl);
            font-weight: 400;
            color: var(--white-100);
            direction: rtl;
            line-height: 1.4;
        }

        .quote-english {
            font-size: var(--text-lg);
            font-weight: 400;
            color: var(--white-80);
            letter-spacing: var(--tracking-normal);
            margin-top: var(--space-sm);
            font-style: italic;
        }

        .quote-source {
            font-size: var(--text-sm);
            font-weight: 500;
            color: var(--white-40);
            letter-spacing: var(--tracking-wide);
            margin-top: var(--space-sm);
            text-transform: uppercase;
        }

        /* ========================================
           FORECAST - Bottom center strip
           ======================================== */
        .forecast {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 56px;
            display: flex;
            justify-content: center;
            z-index: 50;
            pointer-events: none;
        }

        .forecast-segment {
            width: 72px;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-right: 1px solid rgba(255,255,255,0.04);
        }

        .forecast-segment:last-child {
            border-right: none;
        }

        .forecast-time {
            font-size: var(--text-xs);
            color: var(--white-40);
            font-weight: 500;
            letter-spacing: var(--tracking-wide);
        }

        .forecast-temp {
            font-size: var(--text-lg);
            font-weight: 400;
            color: var(--white-80);
            margin-top: var(--space-xs);
        }

        /* ========================================
           LOADING STATE
           ======================================== */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: var(--text-xs);
            letter-spacing: var(--tracking-wider);
            color: var(--white-20);
            text-transform: uppercase;
            z-index: 200;
            transition: opacity 0.5s;
        }

        .loading.hidden { opacity: 0; pointer-events: none; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <!-- Current Time Display -->
    <div class="current-time" id="currentTime">
        <div class="time-display" id="timeDisplay">--:--</div>
        <div class="time-location">Toronto, ON</div>
    </div>

    <div class="label temp" id="temp">--°</div>
    <div class="label feels" id="feels">feels --°</div>

    <div class="label wind" id="windPanel">
        <div class="wind-speed" id="windSpeed">-- km/h</div>
        <div class="wind-dir" id="windDir">--</div>
    </div>

    <div class="zmanim" id="zmanimPanel" style="display: none;">
        <div class="zmanim-label" id="zmanimLabel">--</div>
        <div class="zmanim-time" id="zmanimTime">--:--</div>
        <div class="zmanim-greeting" id="zmanimGreeting"></div>
    </div>

    <div class="label condition" id="condition">--</div>

    <div class="label atmosphere">
        <span id="humidity">--%</span>
        <span id="pressure">-- hPa</span>
    </div>

    <!-- Hebrew Date Display -->
    <div class="hebrew-date" id="hebrewDate">
        <div class="hebrew-date-hebrew" id="hebrewDateHebrew"></div>
        <div class="hebrew-date-phonetic" id="hebrewDatePhonetic"></div>
    </div>

    <!-- Month Theme -->
    <div class="month-theme" id="monthTheme">
        <div class="month-letter" id="monthLetter"></div>
        <div class="month-theme-text" id="monthThemeText"></div>
    </div>

    <!-- Lunar Phase -->
    <div class="lunar-phase" id="lunarPhase">
        <div class="lunar-dots" id="lunarDots"></div>
        <div class="lunar-day" id="lunarDay"></div>
        <div class="lunar-meaning" id="lunarMeaning"></div>
        <div class="lunar-sefirah" id="lunarSefirah"></div>
    </div>

    <!-- Omer Counter -->
    <div class="omer-count" id="omerCount">
        <div class="omer-number" id="omerNumber"></div>
        <div class="omer-sefirot" id="omerSefirot"></div>
    </div>

    <!-- Parsha -->
    <div class="parsha" id="parsha">
        <div class="parsha-label">Parashat</div>
        <div class="parsha-name" id="parshaName"></div>
    </div>

    <!-- Chanukah indicator -->
    <div class="chanukah" id="chanukah">
        <div class="chanukah-text" id="chanukahText"></div>
    </div>

    <!-- Kabbalistic Quote -->
    <div class="quote" id="quote">
        <div class="quote-hebrew" id="quoteHebrew"></div>
        <div class="quote-english" id="quoteEnglish"></div>
        <div class="quote-source" id="quoteSource"></div>
    </div>

    <div class="forecast" id="forecast"></div>

    <div class="loading" id="loading">connecting</div>

    <!-- Three.js for 3D moon -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Hebcal for Hebrew calendar -->
    <script src="https://unpkg.com/@hebcal/core@5.4.1/dist/bundle.min.js"></script>

    <script>
    (function() {
        const CONFIG = {
            LAT: 43.6532,
            LON: -79.3832,
            TIMEZONE: 'America/Toronto',
            LOCATION_NAME: 'Toronto, ON',
            COUNTRY: 'CA',
            API_KEY: 'a73511139cb03d0c96c105790e302b64'
        };

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let W, H, dpr;

        // State
        let mouseX = W / 2, mouseY = H / 2;
        let targetMouseX = W / 2, targetMouseY = H / 2;
        let mouseDown = false;
        let mouseGlowAlpha = 0.05;
        let time = 0;

        // Weather data
        let temp = 15;
        let feelsLike = 15;
        let windSpeed = 10;
        let windDeg = 270;
        let humidity = 50;
        let pressure = 1013;
        let precipIntensity = 0;
        let weatherId = 800;
        let sunrise = 0;
        let sunset = 0;

        // Hebrew calendar state
        let hebrewState = {
            hdate: null,
            dayOfMonth: 0,
            monthName: '',
            monthNameHebrew: '',
            yearNum: 0,
            isShabbat: false,
            isYomTov: false,
            isFriday: false,
            candleLighting: null,
            havdalah: null,
            parsha: null,
            omerDay: 0,
            chanukahNight: 0
        };

        // Shabbat/Yom Tov rest mode state
        let shabbatMode = {
            active: false,
            cachedWeather: null,
            cachedForecast: null,
            cachedQuote: null,
            particleSeed: null,
            activatedAt: null,
            nextHavdalah: null,
            // Intervals to clear when entering Shabbat mode
            weatherInterval: null,
            forecastInterval: null
        };

        // Seeded random number generator for deterministic particle behavior
        class SeededRandom {
            constructor(seed) {
                this.seed = seed;
            }
            next() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
        }
        let shabbatRandom = null; // Initialized when Shabbat mode activates

        // Kabbalistic moon phase meanings
        const MOON_PHASES = {
            newMoon: {
                name: 'Molad',
                days: [1, 2],
                meaning: 'Hiddenness / Potential',
                sefirah: 'Malchut in concealment'
            },
            waxingCrescent: {
                name: 'Growing',
                days: [3, 4, 5, 6, 7],
                meaning: 'Chesed / Expansion',
                sefirah: 'Chesed ascending'
            },
            firstQuarter: {
                name: 'Half Illuminated',
                days: [8, 9, 10],
                meaning: 'Tiferet / Balance',
                sefirah: 'Harmony of forces'
            },
            waxingGibbous: {
                name: 'Nearly Full',
                days: [11, 12, 13, 14],
                meaning: 'Approaching Fullness',
                sefirah: 'Yesod gathering'
            },
            fullMoon: {
                name: 'Full',
                days: [15, 16],
                meaning: 'Revelation / Malchut',
                sefirah: 'Malchut illuminated'
            },
            waningGibbous: {
                name: 'Diminishing',
                days: [17, 18, 19, 20, 21],
                meaning: 'Gevurah / Restraint',
                sefirah: 'Contraction begins'
            },
            lastQuarter: {
                name: 'Half Dark',
                days: [22, 23, 24],
                meaning: 'Din / Judgment',
                sefirah: 'Gevurah prominent'
            },
            waningCrescent: {
                name: 'Fading',
                days: [25, 26, 27, 28, 29, 30],
                meaning: 'Return / Teshuvah',
                sefirah: 'Preparation for renewal'
            }
        };

        // Month spiritual themes
        const MONTH_THEMES = {
            'Nisan': { theme: 'Redemption', letter: 'ה', hebrew: 'ניסן', phonetic: 'nisan' },
            'Iyyar': { theme: 'Healing', letter: 'ו', hebrew: 'אייר', phonetic: 'iyar' },
            'Sivan': { theme: 'Revelation', letter: 'ז', hebrew: 'סיון', phonetic: 'sivan' },
            'Tamuz': { theme: 'Vision', letter: 'ח', hebrew: 'תמוז', phonetic: 'tamuz' },
            'Av': { theme: 'Hearing', letter: 'ט', hebrew: 'אב', phonetic: 'av' },
            'Elul': { theme: 'Teshuvah', letter: 'י', hebrew: 'אלול', phonetic: 'elul' },
            'Tishrei': { theme: 'Beginning', letter: 'ל', hebrew: 'תשרי', phonetic: 'tishrei' },
            'Cheshvan': { theme: 'Depth', letter: 'נ', hebrew: 'חשון', phonetic: 'cheshvan' },
            'Kislev': { theme: 'Dreams', letter: 'ס', hebrew: 'כסלו', phonetic: 'kislev' },
            'Tevet': { theme: 'Rectification', letter: 'ע', hebrew: 'טבת', phonetic: 'tevet' },
            'Sh\'vat': { theme: 'Renewal', letter: 'צ', hebrew: 'שבט', phonetic: 'shvat' },
            'Adar': { theme: 'Joy', letter: 'ק', hebrew: 'אדר', phonetic: 'adar' },
            'Adar I': { theme: 'Hidden Joy', letter: 'ק', hebrew: 'אדר א׳', phonetic: 'adar alef' },
            'Adar II': { theme: 'Revealed Joy', letter: 'ק', hebrew: 'אדר ב׳', phonetic: 'adar bet' }
        };

        // Sefirot for Omer counting
        const SEFIROT = ['Chesed', 'Gevurah', 'Tiferet', 'Netzach', 'Hod', 'Yesod', 'Malchut'];

        // Chanukah quotes by night - Kabbalistic themes
        const CHANUKAH_QUOTES = {
            1: { hebrew: 'נֵר ה׳ נִשְׁמַת אָדָם', english: 'The soul of man is the lamp of God', source: 'Proverbs 20:27' },
            2: { hebrew: 'אוֹר הַגָּנוּז לַצַּדִּיקִים', english: 'The hidden light reserved for the righteous', source: 'Zohar' },
            3: { hebrew: 'בְּאוֹר פָּנֶיךָ יְהַלֵּכוּן', english: 'In the light of Your countenance they walk', source: 'Psalms 89:16' },
            4: { hebrew: 'הַנֵּרוֹת הַלָּלוּ קֹדֶשׁ הֵם', english: 'These lights are holy', source: 'Chanukah Liturgy' },
            5: { hebrew: 'לֹא בְחַיִל וְלֹא בְכֹחַ כִּי אִם בְּרוּחִי', english: 'Not by might nor by power, but by My spirit', source: 'Zechariah 4:6' },
            6: { hebrew: 'כִּי עִמְּךָ מְקוֹר חַיִּים בְּאוֹרְךָ נִרְאֶה אוֹר', english: 'For with You is the fountain of life; in Your light we see light', source: 'Psalms 36:10' },
            7: { hebrew: 'וְהָיָה ה׳ לִי לְאוֹר עוֹלָם', english: 'And God shall be my everlasting light', source: 'Isaiah 60:19' },
            8: { hebrew: 'אוֹר חָדָשׁ עַל צִיּוֹן תָּאִיר', english: 'A new light shall shine upon Zion', source: 'Morning Liturgy' }
        };

        // Shabbat quotes - Kabbalistic
        const SHABBAT_QUOTES = {
            friday: { hebrew: 'נְשָׁמָה יְתֵרָה', english: 'The additional soul descends', source: 'Talmud Beitzah 16a' },
            saturday: { hebrew: 'מֵעֵין עוֹלָם הַבָּא', english: 'A taste of the world to come', source: 'Talmud Berachot 57b' }
        };

        // Moon phase quotes (fallback)
        const MOON_QUOTES = {
            newMoon: { hebrew: 'בְּרֵאשִׁית בָּרָא אֱלֹהִים', english: 'In the beginning, God created', source: 'Genesis 1:1' },
            waxingCrescent: { hebrew: 'וַיֹּאמֶר אֱלֹהִים יְהִי אוֹר', english: 'And God said, let there be light', source: 'Genesis 1:3' },
            firstQuarter: { hebrew: 'עֵץ חַיִּים הִיא לַמַּחֲזִיקִים בָּהּ', english: 'She is a tree of life to those who hold her', source: 'Proverbs 3:18' },
            waxingGibbous: { hebrew: 'אוֹר זָרֻעַ לַצַּדִּיק', english: 'Light is sown for the righteous', source: 'Psalms 97:11' },
            fullMoon: { hebrew: 'מָלְאָה הָאָרֶץ דֵּעָה', english: 'The earth shall be full of knowledge', source: 'Isaiah 11:9' },
            waningGibbous: { hebrew: 'לֵב טָהוֹר בְּרָא לִי אֱלֹהִים', english: 'Create in me a pure heart, O God', source: 'Psalms 51:12' },
            lastQuarter: { hebrew: 'מִמַּעֲמַקִּים קְרָאתִיךָ', english: 'From the depths I call to You', source: 'Psalms 130:1' },
            waningCrescent: { hebrew: 'הַמְחַדֵּשׁ בְּטוּבוֹ בְּכָל יוֹם', english: 'Who renews in goodness each day', source: 'Morning Liturgy' }
        };

        function getOmerSefirot(day) {
            if (day < 1 || day > 49) return null;
            const week = Math.floor((day - 1) / 7);
            const dayInWeek = (day - 1) % 7;
            return {
                primary: SEFIROT[dayInWeek],
                secondary: SEFIROT[week],
                combined: `${SEFIROT[dayInWeek]} within ${SEFIROT[week]}`
            };
        }

        function getMoonPhaseForDay(day) {
            for (const [key, phase] of Object.entries(MOON_PHASES)) {
                if (phase.days.includes(day)) {
                    return phase;
                }
            }
            return MOON_PHASES.newMoon;
        }

        // Particle pool
        let particles = [];
        const MAX_PARTICLES = 1500;

        // Humidity field circles
        let humidityCircles = [];

        // Precipitation burst rotation
        let precipRotation = 0;

        function resize() {
            dpr = window.devicePixelRatio || 1;
            W = window.innerWidth;
            H = window.innerHeight;
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            canvas.style.width = W + 'px';
            canvas.style.height = H + 'px';
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);

            mouseX = W / 2;
            mouseY = H / 2;
            targetMouseX = W / 2;
            targetMouseY = H / 2;

            initHumidityCircles();
        }

        // Temperature to color mapping - neutral dark tones
        function getTempColor(t) {
            // Use dark blue-grey tones instead of temperature-based colors
            const norm = Math.max(0, Math.min(1, (t + 10) / 45));
            const light = 8 + norm * 6; // Very subtle variation 8-14%
            return `hsl(220, 15%, ${light}%)`;
        }

        function getTempColorRGB(t) {
            const norm = Math.max(0, Math.min(1, (t + 10) / 45));
            const hue = 240 - norm * 220;
            const h = hue / 360;
            const s = (30 + norm * 30) / 100;
            const l = (10 + norm * 35) / 100;

            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return { r: r * 255, g: g * 255, b: b * 255 };
        }

        // Turbulent noise field
        const noiseScale = 0.003;
        const noiseTime = { t: 0 };

        function noise2D(x, y, t) {
            return Math.sin(x * 1.2 + t) * Math.cos(y * 0.9 + t * 0.7) +
                   Math.sin(x * 0.7 - y * 1.1 + t * 0.5) * 0.5 +
                   Math.cos(x * 2.1 + y * 1.7 - t * 0.3) * 0.25;
        }

        // Wind-driven particles - follow actual wind direction and speed from API
        class Particle {
            constructor() {
                this.reset(true);
            }

            reset(initial = false) {
                this.depth = 0.3 + Math.random() * 0.7;

                // Wind blows FROM windDeg, so particles move in opposite direction
                // Convert meteorological degrees (0=N, 90=E, 180=S, 270=W) to math angle
                // windDeg is where wind comes FROM, add 180 to get where it's going
                const windRadians = ((windDeg + 180) % 360) * Math.PI / 180;
                const angleVariance = (Math.random() - 0.5) * 0.3;
                this.baseAngle = windRadians + angleVariance;

                // Calculate velocity FIRST to determine spawn position
                const baseSpeed = Math.max(0.05, windSpeed * 0.008);
                this.speed = baseSpeed * this.depth * (0.7 + Math.random() * 0.6);
                this.vx = Math.cos(this.baseAngle) * this.speed;
                this.vy = Math.sin(this.baseAngle) * this.speed;

                if (initial) {
                    this.x = Math.random() * W;
                    this.y = Math.random() * H;
                } else {
                    // Spawn from edge OPPOSITE to movement direction
                    // So particles drift onto screen, not off it
                    if (Math.abs(this.vx) > Math.abs(this.vy)) {
                        // Mostly horizontal movement - spawn on left or right edge
                        this.x = this.vx > 0 ? -50 - Math.random() * 50 : W + 50 + Math.random() * 50;
                        this.y = Math.random() * H;
                    } else {
                        // Mostly vertical movement - spawn on top or bottom edge
                        this.x = Math.random() * W;
                        this.y = this.vy > 0 ? -50 - Math.random() * 50 : H + 50 + Math.random() * 50;
                    }
                }

                this.size = (0.8 + Math.random() * 2.0) * this.depth;
                this.baseAlpha = (0.12 + Math.random() * 0.2) * this.depth;
                this.alpha = this.baseAlpha;

                // Gentle turbulence for organic movement
                this.turbulence = 0.15 + Math.random() * 0.2;

                this.oscPhase = Math.random() * Math.PI * 2;
                this.oscSpeed = 0.001 + Math.random() * 0.002;
                this.oscAmp = 0.08 + Math.random() * 0.12;

                this.trail = [];
                this.maxTrail = 8 + Math.floor(Math.random() * 6);
            }

            update() {
                this.oscPhase += this.oscSpeed;
                noiseTime.t += 0.000001;

                const nx = this.x * noiseScale * 0.3;
                const ny = this.y * noiseScale * 0.3;
                const n = noise2D(nx, ny, noiseTime.t * 5);

                const osc = Math.sin(this.oscPhase) * this.oscAmp;
                const turbAngle = n * Math.PI * this.turbulence + osc;
                const turbVx = Math.cos(this.baseAngle + turbAngle) * this.speed;
                const turbVy = Math.sin(this.baseAngle + turbAngle) * this.speed;

                // Mouse interaction
                const dx = this.x - mouseX;
                const dy = this.y - mouseY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const radius = mouseDown ? 200 : 150;

                let mouseVx = 0, mouseVy = 0;
                if (dist < radius && dist > 5) {
                    const force = (1 - dist / radius) * (mouseDown ? 2 : 1) * this.depth;
                    const repel = force * 0.2;
                    const swirl = force * 0.15;
                    mouseVx = (dx / dist) * repel + (-dy / dist) * swirl;
                    mouseVy = (dy / dist) * repel + (dx / dist) * swirl;
                }

                this.vx += (turbVx - this.vx) * 0.008 + mouseVx * 0.03;
                this.vy += (turbVy - this.vy) * 0.008 + mouseVy * 0.03;

                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrail) this.trail.shift();

                this.x += this.vx;
                this.y += this.vy;

                // Fade near edges (all sides)
                const edgeFade = 80;
                let edgeAlpha = 1;
                if (this.x < edgeFade) edgeAlpha = Math.min(edgeAlpha, this.x / edgeFade);
                if (this.x > W - edgeFade) edgeAlpha = Math.min(edgeAlpha, (W - this.x) / edgeFade);
                if (this.y < edgeFade) edgeAlpha = Math.min(edgeAlpha, this.y / edgeFade);
                if (this.y > H - edgeFade) edgeAlpha = Math.min(edgeAlpha, (H - this.y) / edgeFade);
                this.alpha = this.baseAlpha * Math.max(0, edgeAlpha);

                // Reset when particle exits screen
                if (this.x < -100 || this.x > W + 100 || this.y < -100 || this.y > H + 100) {
                    this.reset();
                }
            }

            draw() {
                // Alpha is already calculated with fade zones in update()
                const glow = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 4);
                glow.addColorStop(0, `rgba(255, 255, 255, ${this.alpha})`);
                glow.addColorStop(0.4, `rgba(220, 225, 235, ${this.alpha * 0.4})`);
                glow.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function initParticles() {
            particles = [];
            const count = 800; // Fixed count for even distribution
            for (let i = 0; i < count; i++) {
                particles.push(new Particle());
            }
        }

        function updateParticleCount() {
            // Particles are now ambient - no wind-based updates needed
        }

        function initHumidityCircles() {
            humidityCircles = [];
            for (let i = 0; i < 15; i++) {
                humidityCircles.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    radius: 150 + Math.random() * 200,
                    phase: Math.random() * Math.PI * 2
                });
            }
        }

        // Draw temperature gradient background
        function drawBackground() {
            // Deep night sky gradient - neutral dark blue
            const grad = ctx.createLinearGradient(0, 0, 0, H);
            grad.addColorStop(0, '#0a0c14');    // Very dark blue-black at top
            grad.addColorStop(0.5, '#0d1018');  // Slightly lighter in middle
            grad.addColorStop(1, '#080a10');    // Dark at bottom

            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, W, H);

            // Subtle vignette
            const vignette = ctx.createRadialGradient(W/2, H/2, 0, W/2, H/2, Math.max(W, H) * 0.7);
            vignette.addColorStop(0, 'rgba(0,0,0,0)');
            vignette.addColorStop(1, 'rgba(0,0,0,0.3)');
            ctx.fillStyle = vignette;
            ctx.fillRect(0, 0, W, H);

            // Shabbat warmth overlay
            if (hebrewState.isShabbat) {
                const shabbatGlow = ctx.createRadialGradient(
                    W / 2, H * 0.4, 0,
                    W / 2, H * 0.4, Math.min(W, H) * 0.6
                );
                shabbatGlow.addColorStop(0, 'rgba(255, 220, 170, 0.04)');
                shabbatGlow.addColorStop(0.5, 'rgba(255, 210, 150, 0.02)');
                shabbatGlow.addColorStop(1, 'rgba(255, 200, 130, 0)');
                ctx.fillStyle = shabbatGlow;
                ctx.fillRect(0, 0, W, H);
            }
        }

        // ============================================
        // 3D MOON
        // ============================================

        let moonScene, moonCamera, moonRenderer, moonSphere, moonLight;
        let moonCanvas, moonReady = false;
        let texturesLoaded = { color: false, bump: false };

        function initMoon3D() {
            moonCanvas = document.createElement('canvas');
            moonCanvas.width = 1024;
            moonCanvas.height = 1024;

            moonScene = new THREE.Scene();

            const frustumSize = 2.2;
            moonCamera = new THREE.OrthographicCamera(
                -frustumSize / 2, frustumSize / 2,
                frustumSize / 2, -frustumSize / 2,
                0.1, 100
            );
            moonCamera.position.z = 5;

            moonRenderer = new THREE.WebGLRenderer({
                canvas: moonCanvas,
                alpha: true,
                antialias: true
            });
            moonRenderer.setSize(1024, 1024);
            moonRenderer.setClearColor(0x000000, 0);
            moonRenderer.outputEncoding = THREE.sRGBEncoding;

            const geometry = new THREE.SphereGeometry(1, 128, 128);

            const textureLoader = new THREE.TextureLoader();

            const colorTexture = textureLoader.load(
                'assets/moon_texture_4k.jpg',
                (tex) => {
                    tex.encoding = THREE.sRGBEncoding;
                    texturesLoaded.color = true;
                    checkReady();
                },
                undefined,
                (err) => {
                    console.error('Color texture failed:', err);
                    textureLoader.load(
                        'https://www.solarsystemscope.com/textures/download/2k_moon.jpg',
                        (tex) => {
                            tex.encoding = THREE.sRGBEncoding;
                            moonSphere.material.map = tex;
                            moonSphere.material.needsUpdate = true;
                            texturesLoaded.color = true;
                            checkReady();
                        }
                    );
                }
            );

            const bumpTexture = textureLoader.load(
                'assets/moon_bump_4k.jpg',
                () => {
                    texturesLoaded.bump = true;
                    checkReady();
                },
                undefined,
                (err) => console.warn('Bump texture failed:', err)
            );

            function checkReady() {
                if (texturesLoaded.color) {
                    moonReady = true;
                }
            }

            const material = new THREE.MeshPhongMaterial({
                map: colorTexture,
                bumpMap: bumpTexture,
                bumpScale: 0.015,
                shininess: 0,
                reflectivity: 0
            });

            moonSphere = new THREE.Mesh(geometry, material);
            moonScene.add(moonSphere);

            moonLight = new THREE.DirectionalLight(0xfffaf0, 2.5);
            moonScene.add(moonLight);

            const earthshine = new THREE.AmbientLight(0x1a2540, 0.08);
            moonScene.add(earthshine);

            // Glow shader
            const glowGeometry = new THREE.SphereGeometry(1.0, 64, 64);
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    glowColor: { value: new THREE.Color(0xd0d8f0) },
                    viewVector: { value: moonCamera.position }
                },
                vertexShader: `
                    uniform vec3 viewVector;
                    varying float intensity;
                    void main() {
                        vec3 vNormal = normalize(normalMatrix * normal);
                        vec3 vNormel = normalize(normalMatrix * viewVector);
                        float rim = 1.0 - dot(vNormal, vNormel);
                        intensity = pow(rim, 4.0) * smoothstep(0.6, 1.0, rim);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 glowColor;
                    varying float intensity;
                    void main() {
                        float softIntensity = intensity * 0.25;
                        vec3 glow = glowColor * softIntensity;
                        gl_FragColor = vec4(glow, softIntensity * 0.3);
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false
            });
            const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
            glowMesh.scale.multiplyScalar(1.04);
            moonScene.add(glowMesh);

            const outerGlowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    glowColor: { value: new THREE.Color(0xe0e6ff) },
                    viewVector: { value: moonCamera.position }
                },
                vertexShader: `
                    uniform vec3 viewVector;
                    varying float intensity;
                    void main() {
                        vec3 vNormal = normalize(normalMatrix * normal);
                        vec3 vNormel = normalize(normalMatrix * viewVector);
                        float rim = 1.0 - dot(vNormal, vNormel);
                        intensity = pow(rim, 2.5) * smoothstep(0.4, 1.0, rim);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 glowColor;
                    varying float intensity;
                    void main() {
                        float softIntensity = intensity * 0.1;
                        vec3 glow = glowColor * softIntensity;
                        gl_FragColor = vec4(glow, softIntensity * 0.125);
                    }
                `,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false
            });
            const outerGlowMesh = new THREE.Mesh(glowGeometry.clone(), outerGlowMaterial);
            outerGlowMesh.scale.multiplyScalar(1.08);
            moonScene.add(outerGlowMesh);
        }

        // Astronomical calculations
        function toRad(deg) { return deg * Math.PI / 180; }
        function toDeg(rad) { return rad * 180 / Math.PI; }
        function normalize(deg) { return ((deg % 360) + 360) % 360; }

        function getJulianDate(date) {
            const y = date.getUTCFullYear();
            const m = date.getUTCMonth() + 1;
            const d = date.getUTCDate();
            const h = date.getUTCHours() + date.getUTCMinutes() / 60 + date.getUTCSeconds() / 3600;

            let jd = 367 * y - Math.floor(7 * (y + Math.floor((m + 9) / 12)) / 4);
            jd += Math.floor(275 * m / 9) + d + 1721013.5 + h / 24;
            return jd;
        }

        function getMoonPhaseAngle(jd) {
            // Reference: January 6, 2000 new moon (well-documented astronomical event)
            const knownNewMoon = 2451550.1;
            const synodicMonth = 29.530588853;
            const daysSinceNew = jd - knownNewMoon;
            let phase = ((daysSinceNew % synodicMonth) + synodicMonth) % synodicMonth;
            phase = phase / synodicMonth;
            const angle = phase * 360;
            return angle;
        }

        function getMoonPosition(jd, lat, lon) {
            const T = (jd - 2451545.0) / 36525;

            const L = normalize(218.3164477 + 481267.88123421 * T);
            const D = normalize(297.8501921 + 445267.1114034 * T);
            const M = normalize(134.9633964 + 477198.8675055 * T);
            const F = normalize(93.2720950 + 483202.0175233 * T);
            const Ms = normalize(357.5291092 + 35999.0502909 * T);

            const dL = 6.289 * Math.sin(toRad(M))
                     + 1.274 * Math.sin(toRad(2 * D - M))
                     + 0.658 * Math.sin(toRad(2 * D))
                     + 0.214 * Math.sin(toRad(2 * M))
                     - 0.186 * Math.sin(toRad(Ms))
                     - 0.114 * Math.sin(toRad(2 * F));

            const moonLon = L + dL;
            const moonLat = 5.128 * Math.sin(toRad(F));

            const obliquity = 23.439 - 0.00000036 * (jd - 2451545.0);
            const ra = toDeg(Math.atan2(
                Math.sin(toRad(moonLon)) * Math.cos(toRad(obliquity)) - Math.tan(toRad(moonLat)) * Math.sin(toRad(obliquity)),
                Math.cos(toRad(moonLon))
            ));
            const dec = toDeg(Math.asin(
                Math.sin(toRad(moonLat)) * Math.cos(toRad(obliquity)) +
                Math.cos(toRad(moonLat)) * Math.sin(toRad(obliquity)) * Math.sin(toRad(moonLon))
            ));

            const gmst = normalize(280.46061837 + 360.98564736629 * (jd - 2451545.0));
            const lst = normalize(gmst + lon);
            const ha = lst - normalize(ra);

            const altitude = toDeg(Math.asin(
                Math.sin(toRad(lat)) * Math.sin(toRad(dec)) +
                Math.cos(toRad(lat)) * Math.cos(toRad(dec)) * Math.cos(toRad(ha))
            ));

            const azimuth = toDeg(Math.atan2(
                Math.sin(toRad(ha)),
                Math.cos(toRad(ha)) * Math.sin(toRad(lat)) - Math.tan(toRad(dec)) * Math.cos(toRad(lat))
            ));

            return {
                altitude,
                azimuth: normalize(azimuth + 180)
            };
        }

        function renderMoon3D() {
            if (!moonReady || !moonSphere) return;

            const now = new Date();
            const jd = getJulianDate(now);

            const phaseAngle = getMoonPhaseAngle(jd);

            moonSphere.rotation.x = 0;
            moonSphere.rotation.y = -Math.PI / 2;
            moonSphere.rotation.z = 0;

            const lightAngle = toRad(phaseAngle);
            const lightX = Math.sin(lightAngle) * 10;
            const lightY = 0;
            const lightZ = -Math.cos(lightAngle) * 10;

            moonLight.position.set(lightX, lightY, lightZ);

            moonRenderer.render(moonScene, moonCamera);
        }

        if (typeof THREE !== 'undefined') {
            initMoon3D();
        }

        function drawMoon() {
            renderMoon3D();

            const mx = W * 0.5;
            const my = H * 0.42;
            const R = Math.min(W, H) * 0.28;

            if (moonReady && moonCanvas) {
                ctx.drawImage(moonCanvas, mx - R, my - R, R * 2, R * 2);
            } else {
                // Fallback: draw a nice moon with phase shading
                drawFallbackMoon(mx, my, R);
            }
        }

        function drawFallbackMoon(mx, my, R) {
            // Get phase from Hebrew date (day 1 = new, day 15 = full)
            const day = hebrewState.dayOfMonth || 15;
            const phase = (day - 1) / 29.5; // 0 = new, 0.5 = full, 1 = new again

            // Moon base - soft grey
            const moonGrad = ctx.createRadialGradient(
                mx - R * 0.3, my - R * 0.3, 0,
                mx, my, R
            );
            moonGrad.addColorStop(0, 'rgba(220, 220, 225, 0.95)');
            moonGrad.addColorStop(0.5, 'rgba(180, 180, 190, 0.9)');
            moonGrad.addColorStop(1, 'rgba(140, 140, 155, 0.85)');

            ctx.beginPath();
            ctx.arc(mx, my, R, 0, Math.PI * 2);
            ctx.fillStyle = moonGrad;
            ctx.fill();

            // Add some crater-like texture
            ctx.globalAlpha = 0.15;
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 + 0.5;
                const dist = R * (0.3 + Math.random() * 0.5);
                const cx = mx + Math.cos(angle) * dist;
                const cy = my + Math.sin(angle) * dist;
                const cr = R * (0.05 + Math.random() * 0.1);

                ctx.beginPath();
                ctx.arc(cx, cy, cr, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(100, 100, 120, 0.5)';
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Phase shadow
            ctx.save();
            ctx.beginPath();
            ctx.arc(mx, my, R, 0, Math.PI * 2);
            ctx.clip();

            if (phase < 0.5) {
                // Waxing - shadow on left, light from right
                const shadowAmount = 1 - (phase * 2); // 1 at new, 0 at full
                const shadowGrad = ctx.createLinearGradient(mx - R, my, mx + R, my);
                shadowGrad.addColorStop(0, `rgba(10, 10, 18, ${shadowAmount * 0.95})`);
                shadowGrad.addColorStop(Math.min(0.9, shadowAmount), `rgba(10, 10, 18, ${shadowAmount * 0.3})`);
                shadowGrad.addColorStop(1, 'rgba(10, 10, 18, 0)');
                ctx.fillStyle = shadowGrad;
                ctx.fillRect(mx - R, my - R, R * 2, R * 2);
            } else {
                // Waning - shadow on right, light from left
                const shadowAmount = (phase - 0.5) * 2; // 0 at full, 1 at new
                const shadowGrad = ctx.createLinearGradient(mx + R, my, mx - R, my);
                shadowGrad.addColorStop(0, `rgba(10, 10, 18, ${shadowAmount * 0.95})`);
                shadowGrad.addColorStop(Math.min(0.9, shadowAmount), `rgba(10, 10, 18, ${shadowAmount * 0.3})`);
                shadowGrad.addColorStop(1, 'rgba(10, 10, 18, 0)');
                ctx.fillStyle = shadowGrad;
                ctx.fillRect(mx - R, my - R, R * 2, R * 2);
            }
            ctx.restore();

            // Soft glow around moon
            const glowGrad = ctx.createRadialGradient(mx, my, R * 0.9, mx, my, R * 1.3);
            glowGrad.addColorStop(0, 'rgba(200, 210, 230, 0)');
            glowGrad.addColorStop(0.5, 'rgba(200, 210, 230, 0.1)');
            glowGrad.addColorStop(1, 'rgba(200, 210, 230, 0)');
            ctx.fillStyle = glowGrad;
            ctx.beginPath();
            ctx.arc(mx, my, R * 1.3, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawHumidityField() {
            const opacity = (humidity / 100) * 0.25;
            if (opacity < 0.02) return;

            humidityCircles.forEach((circle, i) => {
                circle.phase += 0.001;
                circle.x += Math.sin(circle.phase) * 0.1;
                if (circle.x < -circle.radius) circle.x = W + circle.radius;
                if (circle.x > W + circle.radius) circle.x = -circle.radius;

                const grad = ctx.createRadialGradient(
                    circle.x, circle.y, 0,
                    circle.x, circle.y, circle.radius
                );
                grad.addColorStop(0, `rgba(255, 255, 255, ${opacity})`);
                grad.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, circle.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawPrecipitationBurst() {
            if (precipIntensity < 0.1) return;

            const centerX = W / 2;
            const centerY = H / 2;
            const lineCount = Math.floor(precipIntensity * 36);
            const length = 80 + precipIntensity * 250;

            precipRotation += 0.15;

            ctx.strokeStyle = `rgba(255, 255, 255, ${0.03 + precipIntensity * 0.05})`;
            ctx.lineWidth = 1;

            for (let i = 0; i < lineCount; i++) {
                const angle = ((i / lineCount) * 360 + precipRotation) * Math.PI / 180;
                const x1 = centerX + Math.cos(angle) * 40;
                const y1 = centerY + Math.sin(angle) * 40;
                const x2 = centerX + Math.cos(angle) * length;
                const y2 = centerY + Math.sin(angle) * length;

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
        }

        function drawPressureBar() {
            const minP = 980;
            const maxP = 1030;
            const norm = Math.max(0, Math.min(1, (pressure - minP) / (maxP - minP)));
            const barHeight = H * (0.2 + norm * 0.5);
            const barWidth = 3;
            const x = W - 25;

            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fillRect(x, H - barHeight, barWidth, barHeight);

            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            for (let i = 0; i <= 5; i++) {
                const tickY = H - (H * 0.2) - (i / 5) * (H * 0.5);
                ctx.fillRect(x - 5, tickY - 0.5, 4, 1);
            }
        }

        function drawConditionIcon() {
            const cx = W / 2;
            const cy = 55;
            const size = 24;
            const t = time * 0.001;

            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            if (weatherId === 800) {
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(t * 0.2);

                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1.5;
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.moveTo(Math.cos(angle) * size * 0.5, Math.sin(angle) * size * 0.5);
                    ctx.lineTo(Math.cos(angle) * size, Math.sin(angle) * size);
                    ctx.stroke();
                }

                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.35, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();

            } else if (weatherId >= 801 && weatherId < 900) {
                const drift = Math.sin(t * 0.5) * 2;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.beginPath();
                ctx.arc(cx - 12 + drift, cy + 4, size * 0.5, 0, Math.PI * 2);
                ctx.arc(cx + 2 + drift, cy + 2, size * 0.6, 0, Math.PI * 2);
                ctx.arc(cx + 14 + drift, cy + 5, size * 0.45, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'rgba(255, 255, 255, 0.35)';
                ctx.beginPath();
                ctx.arc(cx - 8, cy - 2, size * 0.4, 0, Math.PI * 2);
                ctx.arc(cx + 4, cy - 4, size * 0.55, 0, Math.PI * 2);
                ctx.arc(cx + 16, cy, size * 0.38, 0, Math.PI * 2);
                ctx.fill();

            } else if (weatherId >= 500 && weatherId < 600 || weatherId >= 300 && weatherId < 400) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 1.5;

                for (let i = -2; i <= 2; i++) {
                    const dropOffset = ((t * 80 + i * 30) % 30) - 5;
                    const alpha = 0.2 + (1 - dropOffset / 25) * 0.3;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.beginPath();
                    ctx.moveTo(cx + i * 10, cy - 10 + dropOffset);
                    ctx.lineTo(cx + i * 10 + 3, cy + 8 + dropOffset);
                    ctx.stroke();
                }

            } else if (weatherId >= 600 && weatherId < 700) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1.5;

                for (let j = 0; j < 3; j++) {
                    const ox = (j - 1) * 18;
                    const oy = Math.sin(t + j * 2) * 5;
                    const rot = t * 0.5 + j;

                    ctx.save();
                    ctx.translate(cx + ox, cy + oy);
                    ctx.rotate(rot);

                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * 8, Math.sin(angle) * 8);
                        ctx.stroke();
                    }
                    ctx.restore();
                }

            } else if (weatherId >= 200 && weatherId < 300) {
                const flash = Math.sin(t * 8) > 0.9 ? 0.8 : 0.4;
                ctx.strokeStyle = `rgba(255, 255, 255, ${flash})`;
                ctx.fillStyle = `rgba(255, 255, 255, ${flash * 0.5})`;
                ctx.lineWidth = 2;

                ctx.beginPath();
                ctx.moveTo(cx + 5, cy - size);
                ctx.lineTo(cx - 5, cy);
                ctx.lineTo(cx + 2, cy);
                ctx.lineTo(cx - 5, cy + size);
                ctx.lineTo(cx + 8, cy - 2);
                ctx.lineTo(cx, cy - 2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

            } else if (weatherId >= 700 && weatherId < 800) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.35)';
                ctx.lineWidth = 2;

                for (let i = -1; i <= 1; i++) {
                    ctx.beginPath();
                    for (let x = -size; x <= size; x += 2) {
                        const wave = Math.sin(x * 0.15 + t + i) * 3;
                        const px = cx + x;
                        const py = cy + i * 10 + wave;
                        if (x === -size) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
            }
        }

        function drawParticles() {
            particles.forEach(p => {
                p.update();
                p.draw();
            });
        }

        function drawMouseGlow() {
            const targetAlpha = mouseDown ? 0.12 : 0.04;
            mouseGlowAlpha += (targetAlpha - mouseGlowAlpha) * 0.1;

            const radius = mouseDown ? 120 : 80;
            const grad = ctx.createRadialGradient(mouseX, mouseY, 0, mouseX, mouseY, radius);
            grad.addColorStop(0, `rgba(255, 255, 255, ${mouseGlowAlpha})`);
            grad.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(mouseX, mouseY, radius, 0, Math.PI * 2);
            ctx.fill();
        }

        // Main render loop
        function render() {
            time++;

            mouseX += (targetMouseX - mouseX) * 0.1;
            mouseY += (targetMouseY - mouseY) * 0.1;

            ctx.clearRect(0, 0, W, H);

            drawBackground();
            drawHumidityField();
            drawParticles();        // Draw particles behind moon
            drawMoon();             // Moon on top
            // drawPrecipitationBurst(); // Removed - clean aesthetic
            // drawPressureBar();        // Removed - white line artifact
            // drawConditionIcon();      // Removed - clean aesthetic
            drawMouseGlow();

            requestAnimationFrame(render);
        }

        // ============================================
        // HEBREW CALENDAR FUNCTIONS
        // ============================================

        // Major Yom Tov holidays that require rest mode (same as Shabbat)
        const YOM_TOV_HOLIDAYS = [
            'Rosh Hashana',
            'Yom Kippur',
            'Sukkot I',
            'Sukkot II',
            'Shmini Atzeret',
            'Simchat Torah',
            'Pesach I',
            'Pesach II',
            'Pesach VII',
            'Pesach VIII',
            'Shavuot I',
            'Shavuot II'
        ];

        // Check if currently in Shabbat or Yom Tov rest period
        function isRestPeriod(now = new Date()) {
            if (typeof hebcal === 'undefined') return false;

            try {
                const location = hebcal.Location.lookup('Toronto');

                // Check a 3-day window to catch candle lighting and havdalah
                const startCheck = new Date(now);
                startCheck.setDate(startCheck.getDate() - 1);
                const endCheck = new Date(now);
                endCheck.setDate(endCheck.getDate() + 1);

                const events = hebcal.HebrewCalendar.calendar({
                    start: startCheck,
                    end: endCheck,
                    location: location,
                    candlelighting: true,
                    yomtov: true
                });

                let candleLightingTime = null;
                let havdalahTime = null;
                let isYomTov = false;

                events.forEach(ev => {
                    const desc = ev.getDesc();
                    const eventTime = ev.eventTime;

                    if (desc.startsWith('Candle lighting') && eventTime) {
                        if (!candleLightingTime || eventTime < candleLightingTime) {
                            // Get the most recent candle lighting before now
                            if (eventTime <= now) {
                                candleLightingTime = eventTime;
                            }
                        }
                    } else if (desc.startsWith('Havdalah') && eventTime) {
                        // Get the next havdalah after the candle lighting
                        if (candleLightingTime && eventTime > candleLightingTime) {
                            if (!havdalahTime || eventTime < havdalahTime) {
                                havdalahTime = eventTime;
                            }
                        }
                    }

                    // Check for Yom Tov
                    if (YOM_TOV_HOLIDAYS.some(h => desc.includes(h))) {
                        isYomTov = true;
                    }
                });

                // Store havdalah time for later reference
                if (havdalahTime) {
                    shabbatMode.nextHavdalah = havdalahTime;
                }

                // Check if we're in a rest period
                if (candleLightingTime && havdalahTime) {
                    return now >= candleLightingTime && now < havdalahTime;
                }

                return false;
            } catch (e) {
                console.error('Rest period check error:', e);
                return false;
            }
        }

        // Get time until next Shabbat/Yom Tov for pre-caching
        function getTimeUntilNextRestPeriod() {
            if (typeof hebcal === 'undefined') return null;

            try {
                const now = new Date();
                const location = hebcal.Location.lookup('Toronto');

                // Look ahead 7 days for next candle lighting
                const endCheck = new Date(now);
                endCheck.setDate(endCheck.getDate() + 7);

                const events = hebcal.HebrewCalendar.calendar({
                    start: now,
                    end: endCheck,
                    location: location,
                    candlelighting: true
                });

                for (const ev of events) {
                    const desc = ev.getDesc();
                    if (desc.startsWith('Candle lighting') && ev.eventTime) {
                        const msUntil = ev.eventTime - now;
                        return {
                            time: ev.eventTime,
                            msUntil: msUntil,
                            hoursUntil: msUntil / (1000 * 60 * 60)
                        };
                    }
                }
                return null;
            } catch (e) {
                console.error('Next rest period check error:', e);
                return null;
            }
        }

        function updateHebrewCalendar() {
            if (typeof hebcal === 'undefined') {
                console.warn('Hebcal not loaded');
                return;
            }

            try {
                const now = new Date();
                const hdate = new hebcal.HDate(now);

                hebrewState.hdate = hdate;
                hebrewState.dayOfMonth = hdate.getDate();
                hebrewState.monthName = hdate.getMonthName();
                hebrewState.yearNum = hdate.getFullYear();

                // Check day of week
                const dayOfWeek = now.getDay();
                hebrewState.isFriday = dayOfWeek === 5;
                hebrewState.isShabbat = dayOfWeek === 6;

                // Get events for today
                const events = hebcal.HebrewCalendar.calendar({
                    start: now,
                    end: now,
                    location: hebcal.Location.lookup('Toronto'),
                    candlelighting: true,
                    sedrot: true,
                    omer: true
                });

                // Reset state
                hebrewState.candleLighting = null;
                hebrewState.havdalah = null;
                hebrewState.parsha = null;
                hebrewState.omerDay = 0;
                hebrewState.chanukahNight = 0;

                // Calculate Chanukah night
                // Chanukah: 25 Kislev - 2/3 Tevet (8 nights)
                const month = hebrewState.monthName;
                const day = hebrewState.dayOfMonth;
                if (month === 'Kislev' && day >= 25) {
                    hebrewState.chanukahNight = day - 24; // 25=night 1, 26=night 2, etc.
                } else if (month === 'Tevet' && day <= 2) {
                    // Kislev can have 29 or 30 days
                    // If we're in Tevet, calculate based on remaining nights
                    const kislev29 = new hebcal.HDate(29, 'Kislev', hebrewState.yearNum);
                    const kislevDays = kislev29.getDate() === 29 ? 29 : 30;
                    const nightsInKislev = kislevDays - 24;
                    hebrewState.chanukahNight = nightsInKislev + day;
                }

                // Process events
                events.forEach(ev => {
                    const desc = ev.getDesc();

                    if (desc.startsWith('Candle lighting')) {
                        hebrewState.candleLighting = ev.eventTime;
                    } else if (desc.startsWith('Havdalah')) {
                        hebrewState.havdalah = ev.eventTime;
                    } else if (desc.startsWith('Parashat')) {
                        hebrewState.parsha = desc.replace('Parashat ', '');
                    } else if (ev.omer) {
                        hebrewState.omerDay = ev.omer;
                    }
                });

                updateHebrewUI();
            } catch (e) {
                console.error('Hebrew calendar error:', e);
            }
        }

        function updateHebrewUI() {
            const { dayOfMonth, monthName, yearNum, isShabbat, isFriday, candleLighting, havdalah, parsha, omerDay, chanukahNight } = hebrewState;

            // Hebrew date display - all Hebrew with phonetic below
            const theme = MONTH_THEMES[monthName];
            const hebrewDay = hebcal.gematriya(dayOfMonth);
            const hebrewYear = hebcal.gematriya(yearNum % 1000);
            const hebrewMonth = theme ? theme.hebrew : monthName;
            const phoneticMonth = theme ? theme.phonetic : monthName.toLowerCase();

            document.getElementById('hebrewDateHebrew').textContent = `${hebrewDay} ${hebrewMonth} ${hebrewYear}`;
            document.getElementById('hebrewDatePhonetic').textContent = `${dayOfMonth} ${phoneticMonth} ${yearNum}`;

            // Month theme
            if (theme) {
                document.getElementById('monthLetter').textContent = theme.letter;
                document.getElementById('monthThemeText').textContent = theme.theme;
            }

            // Lunar phase dots
            updateLunarPhaseUI(dayOfMonth);

            // Zmanim display
            const windPanel = document.getElementById('windPanel');
            const zmanimPanel = document.getElementById('zmanimPanel');

            if (isFriday && candleLighting) {
                windPanel.style.display = 'none';
                zmanimPanel.style.display = 'block';
                document.getElementById('zmanimLabel').textContent = 'Hadlakat Nerot';
                document.getElementById('zmanimTime').textContent = formatTime(candleLighting);
                document.getElementById('zmanimGreeting').textContent = 'Shabbat Shalom';
            } else if (isShabbat && havdalah) {
                windPanel.style.display = 'none';
                zmanimPanel.style.display = 'block';
                document.getElementById('zmanimLabel').textContent = 'Havdalah';
                document.getElementById('zmanimTime').textContent = formatTime(havdalah);
                document.getElementById('zmanimGreeting').textContent = 'Shavua Tov';
            } else {
                windPanel.style.display = 'block';
                zmanimPanel.style.display = 'none';
            }

            // Parsha display
            const parshaEl = document.getElementById('parsha');
            if ((isShabbat || isFriday) && parsha) {
                parshaEl.classList.add('visible');
                document.getElementById('parshaName').textContent = parsha;
            } else {
                parshaEl.classList.remove('visible');
            }

            // Omer display
            const omerEl = document.getElementById('omerCount');
            if (omerDay > 0 && omerDay <= 49) {
                omerEl.classList.add('visible');
                document.getElementById('omerNumber').textContent = `Day ${omerDay} of the Omer`;
                const sefirot = getOmerSefirot(omerDay);
                document.getElementById('omerSefirot').textContent = sefirot.combined;
            } else {
                omerEl.classList.remove('visible');
            }

            // Chanukah candles display
            const chanukahEl = document.getElementById('chanukah');
            if (chanukahNight > 0 && chanukahNight <= 8) {
                chanukahEl.classList.add('visible');
                updateChanukahCandles(chanukahNight);
            } else {
                chanukahEl.classList.remove('visible');
            }

            // Kabbalistic quote - context aware
            updateQuoteDisplay();
        }

        function updateChanukahCandles(night) {
            // Simple text display for Chanukah
            document.getElementById('chanukahText').textContent = `Chanukah · Night ${night}`;
        }

        function getMoonPhaseKey(dayOfMonth) {
            for (const [key, phase] of Object.entries(MOON_PHASES)) {
                if (phase.days.includes(dayOfMonth)) {
                    return key;
                }
            }
            return 'newMoon';
        }

        function updateQuoteDisplay() {
            let quote = null;

            // Priority 1: Chanukah quotes (by night)
            if (hebrewState.chanukahNight > 0 && hebrewState.chanukahNight <= 8) {
                quote = CHANUKAH_QUOTES[hebrewState.chanukahNight];
            }
            // Priority 2: Shabbat quotes
            else if (hebrewState.isShabbat) {
                quote = SHABBAT_QUOTES.saturday;
            }
            else if (hebrewState.isFriday) {
                quote = SHABBAT_QUOTES.friday;
            }
            // Priority 3: Moon phase quotes (fallback)
            else {
                const phaseKey = getMoonPhaseKey(hebrewState.dayOfMonth);
                quote = MOON_QUOTES[phaseKey];
            }

            if (quote) {
                displayQuote(quote);
            }
        }

        // Display a specific quote object
        function displayQuote(quote) {
            if (!quote) return;
            document.getElementById('quoteHebrew').textContent = quote.hebrew;
            document.getElementById('quoteEnglish').textContent = quote.english;
            document.getElementById('quoteSource').textContent = quote.source;
        }

        function updateLunarPhaseUI(dayOfMonth) {
            const totalDays = 30;
            let dotsHtml = '';

            for (let i = 1; i <= totalDays; i++) {
                const isActive = i === dayOfMonth;
                const isFull = i >= 14 && i <= 16;
                let classes = [];
                if (isActive) classes.push('active');
                if (isFull) classes.push('full');
                const symbol = isFull ? '●' : '○';
                dotsHtml += `<span class="${classes.join(' ')}">${symbol}</span>`;
            }

            document.getElementById('lunarDots').innerHTML = dotsHtml;
            document.getElementById('lunarDay').textContent = `Day ${dayOfMonth} of the Moon`;

            const phase = getMoonPhaseForDay(dayOfMonth);
            document.getElementById('lunarMeaning').textContent = phase.meaning;
            document.getElementById('lunarSefirah').textContent = phase.sefirah;
        }

        function formatTime(date) {
            if (!date) return '--:--';
            return date.toLocaleTimeString('en-US', {
                hour: 'numeric',
                minute: '2-digit',
                hour12: false
            });
        }

        // ============================================
        // WEATHER FUNCTIONS
        // ============================================

        const CACHE_DURATION_WEATHER = 30 * 60 * 1000;
        const CACHE_DURATION_FORECAST = 60 * 60 * 1000;

        function getCachedData(key) {
            try {
                const cached = localStorage.getItem(key);
                if (!cached) return null;
                const { data, timestamp } = JSON.parse(cached);
                const maxAge = key.includes('forecast') ? CACHE_DURATION_FORECAST : CACHE_DURATION_WEATHER;
                if (Date.now() - timestamp > maxAge) {
                    localStorage.removeItem(key);
                    return null;
                }
                return data;
            } catch (e) {
                return null;
            }
        }

        function setCachedData(key, data) {
            try {
                localStorage.setItem(key, JSON.stringify({ data, timestamp: Date.now() }));
            } catch (e) {
                console.warn('Cache write failed:', e);
            }
        }

        function applyWeatherData(data) {
            temp = data.main.temp;
            feelsLike = data.main.feels_like;
            windSpeed = data.wind.speed * 3.6;
            windDeg = data.wind.deg || 270;
            humidity = data.main.humidity;
            pressure = data.main.pressure;
            weatherId = data.weather[0].id;

            if (weatherId >= 200 && weatherId < 300) precipIntensity = 8;
            else if (weatherId >= 300 && weatherId < 400) precipIntensity = 2;
            else if (weatherId >= 500 && weatherId < 510) precipIntensity = 4;
            else if (weatherId >= 510 && weatherId < 520) precipIntensity = 6;
            else if (weatherId >= 520 && weatherId < 600) precipIntensity = 9;
            else if (weatherId >= 600 && weatherId < 700) precipIntensity = 5;
            else if (weatherId >= 700 && weatherId < 800) precipIntensity = 1;
            else precipIntensity = 0;

            document.getElementById('temp').textContent = Math.round(temp) + '°';
            document.getElementById('feels').textContent = 'feels ' + Math.round(feelsLike) + '°';
            document.getElementById('windSpeed').textContent = Math.round(windSpeed) + ' km/h';
            document.getElementById('windDir').textContent = getWindDir(windDeg);
            document.getElementById('condition').textContent = data.weather[0].description;
            document.getElementById('humidity').textContent = humidity + '%';
            document.getElementById('pressure').textContent = pressure + ' hPa';

            updateParticleCount();
            document.getElementById('loading').classList.add('hidden');
        }

        async function fetchWeather() {
            // SHABBAT MODE: No network requests
            if (shabbatMode.active) {
                if (shabbatMode.cachedWeather) {
                    applyWeatherData(shabbatMode.cachedWeather);
                }
                return;
            }

            const cacheKey = 'lunar_weather_current';
            const cached = getCachedData(cacheKey);

            if (cached) {
                applyWeatherData(cached);
                return;
            }

            try {
                const res = await fetch(
                    `https://api.openweathermap.org/data/2.5/weather?lat=${CONFIG.LAT}&lon=${CONFIG.LON}&appid=${CONFIG.API_KEY}&units=metric`
                );
                const data = await res.json();

                if (data.main) {
                    setCachedData(cacheKey, data);
                    applyWeatherData(data);
                }
            } catch (e) {
                console.error('Weather error:', e);
            }
        }

        async function fetchForecast() {
            // SHABBAT MODE: No network requests during Shabbat
            if (shabbatMode.active) {
                if (shabbatMode.cachedForecast) {
                    renderForecast(shabbatMode.cachedForecast.list.slice(0, 8));
                }
                return;
            }

            const cacheKey = 'lunar_weather_forecast';
            const cached = getCachedData(cacheKey);

            if (cached) {
                renderForecast(cached.list.slice(0, 8));
                return;
            }

            try {
                const res = await fetch(
                    `https://api.openweathermap.org/data/2.5/forecast?lat=${CONFIG.LAT}&lon=${CONFIG.LON}&appid=${CONFIG.API_KEY}&units=metric`
                );
                const data = await res.json();

                if (data.list) {
                    setCachedData(cacheKey, data);
                    renderForecast(data.list.slice(0, 8));
                }
            } catch (e) {
                console.error('Forecast error:', e);
            }
        }

        function renderForecast(hours) {
            const container = document.getElementById('forecast');
            container.innerHTML = '';

            hours.forEach((hour, i) => {
                const div = document.createElement('div');
                div.className = 'forecast-segment';

                const time = new Date(hour.dt * 1000);
                const timeStr = time.getHours().toString().padStart(2, '0') + ':00';
                const t = Math.round(hour.main.temp);

                const color = getTempColor(hour.main.temp);
                const opacity = 0.7 - (i / 8) * 0.4;
                div.style.background = color;
                div.style.opacity = opacity;

                div.innerHTML = `
                    <div class="forecast-time">${timeStr}</div>
                    <div class="forecast-temp">${t}°</div>
                `;

                container.appendChild(div);
            });
        }

        function getWindDir(deg) {
            const dirs = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
            return dirs[Math.round(deg / 45) % 8];
        }

        // Events
        function initEvents() {
            window.addEventListener('resize', resize);

            document.addEventListener('mousemove', e => {
                // SHABBAT MODE: No mouse interaction
                if (shabbatMode.active) return;
                targetMouseX = e.clientX;
                targetMouseY = e.clientY;
            });

            document.addEventListener('mousedown', () => {
                // SHABBAT MODE: No mouse interaction
                if (shabbatMode.active) return;
                mouseDown = true;
            });

            document.addEventListener('mouseup', () => {
                // SHABBAT MODE: No mouse interaction
                if (shabbatMode.active) return;
                mouseDown = false;
            });

            document.addEventListener('touchmove', e => {
                // SHABBAT MODE: No touch interaction
                if (shabbatMode.active) return;
                if (e.touches.length) {
                    targetMouseX = e.touches[0].clientX;
                    targetMouseY = e.touches[0].clientY;
                }
            }, { passive: true });

            document.addEventListener('touchstart', () => {
                // SHABBAT MODE: No touch interaction
                if (shabbatMode.active) return;
                mouseDown = true;
            }, { passive: true });

            document.addEventListener('touchend', () => {
                // SHABBAT MODE: No touch interaction
                if (shabbatMode.active) return;
                mouseDown = false;
            });
        }

        // ============================================
        // TIME DISPLAY FUNCTIONS
        // ============================================

        function updateTimeDisplay() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                hour12: false,
                timeZone: CONFIG.TIMEZONE
            });
            document.getElementById('timeDisplay').textContent = timeStr;
        }

        // ============================================
        // SHABBAT MODE FUNCTIONS
        // ============================================

        const SHABBAT_CACHE_KEY_WEATHER = 'lunar_shabbat_weather';
        const SHABBAT_CACHE_KEY_FORECAST = 'lunar_shabbat_forecast';
        const SHABBAT_CACHE_KEY_QUOTE = 'lunar_shabbat_quote';
        const SHABBAT_CACHE_KEY_SEED = 'lunar_shabbat_seed';

        // Pre-cache weather and forecast for Shabbat (call before candle lighting)
        async function preCacheForShabbat() {
            console.log('Pre-caching for Shabbat...');
            try {
                // Fetch fresh weather data
                const weatherRes = await fetch(
                    `https://api.openweathermap.org/data/2.5/weather?lat=${CONFIG.LAT}&lon=${CONFIG.LON}&appid=${CONFIG.API_KEY}&units=metric`
                );
                const weatherData = await weatherRes.json();
                if (weatherData.main) {
                    localStorage.setItem(SHABBAT_CACHE_KEY_WEATHER, JSON.stringify({
                        data: weatherData,
                        timestamp: Date.now()
                    }));
                    shabbatMode.cachedWeather = weatherData;
                }

                // Fetch fresh forecast data
                const forecastRes = await fetch(
                    `https://api.openweathermap.org/data/2.5/forecast?lat=${CONFIG.LAT}&lon=${CONFIG.LON}&appid=${CONFIG.API_KEY}&units=metric`
                );
                const forecastData = await forecastRes.json();
                if (forecastData.list) {
                    localStorage.setItem(SHABBAT_CACHE_KEY_FORECAST, JSON.stringify({
                        data: forecastData,
                        timestamp: Date.now()
                    }));
                    shabbatMode.cachedForecast = forecastData;
                }

                // Pre-select quote
                preCacheQuoteForShabbat();

                // Generate particle seed
                const seed = Date.now();
                localStorage.setItem(SHABBAT_CACHE_KEY_SEED, seed.toString());
                shabbatMode.particleSeed = seed;

                console.log('Shabbat pre-cache complete');
            } catch (e) {
                console.error('Shabbat pre-cache error:', e);
            }
        }

        // Pre-select quote for Shabbat
        function preCacheQuoteForShabbat() {
            // Use same priority logic as normal quote selection
            let quote = null;

            // Priority 1: Chanukah (if applicable)
            const chanukahNight = hebrewState.chanukahNight;
            if (chanukahNight > 0 && chanukahNight <= 8 && CHANUKAH_QUOTES[chanukahNight]) {
                quote = CHANUKAH_QUOTES[chanukahNight];
            }
            // Priority 2: Shabbat quotes
            else if (hebrewState.isShabbat || hebrewState.isFriday) {
                quote = SHABBAT_QUOTES.saturday;
            }
            // Priority 3: Moon phase
            else {
                const phaseKey = getMoonPhaseKey(hebrewState.dayOfMonth);
                quote = MOON_QUOTES[phaseKey];
            }

            if (quote) {
                localStorage.setItem(SHABBAT_CACHE_KEY_QUOTE, JSON.stringify(quote));
                shabbatMode.cachedQuote = quote;
            }
        }

        // Activate Shabbat mode
        function activateShabbatMode() {
            if (shabbatMode.active) return;

            console.log('Activating Shabbat mode');
            shabbatMode.active = true;
            shabbatMode.activatedAt = Date.now();

            // Load cached data from localStorage
            try {
                const cachedWeather = localStorage.getItem(SHABBAT_CACHE_KEY_WEATHER);
                if (cachedWeather) {
                    shabbatMode.cachedWeather = JSON.parse(cachedWeather).data;
                }

                const cachedForecast = localStorage.getItem(SHABBAT_CACHE_KEY_FORECAST);
                if (cachedForecast) {
                    shabbatMode.cachedForecast = JSON.parse(cachedForecast).data;
                }

                const cachedQuote = localStorage.getItem(SHABBAT_CACHE_KEY_QUOTE);
                if (cachedQuote) {
                    shabbatMode.cachedQuote = JSON.parse(cachedQuote);
                }

                const cachedSeed = localStorage.getItem(SHABBAT_CACHE_KEY_SEED);
                if (cachedSeed) {
                    shabbatMode.particleSeed = parseInt(cachedSeed, 10);
                }
            } catch (e) {
                console.error('Failed to load Shabbat cache:', e);
            }

            // Initialize seeded random for particles
            shabbatRandom = new SeededRandom(shabbatMode.particleSeed || Date.now());

            // Clear update intervals
            if (shabbatMode.weatherInterval) {
                clearInterval(shabbatMode.weatherInterval);
                shabbatMode.weatherInterval = null;
            }
            if (shabbatMode.forecastInterval) {
                clearInterval(shabbatMode.forecastInterval);
                shabbatMode.forecastInterval = null;
            }

            // Reinitialize particles with seeded random
            initParticlesShabbat();

            // Apply cached weather data
            if (shabbatMode.cachedWeather) {
                applyWeatherData(shabbatMode.cachedWeather);
            }
            if (shabbatMode.cachedForecast) {
                renderForecast(shabbatMode.cachedForecast.list.slice(0, 8));
            }

            // Apply cached quote
            if (shabbatMode.cachedQuote) {
                displayQuote(shabbatMode.cachedQuote);
            }

            console.log('Shabbat mode active');
        }

        // Deactivate Shabbat mode (after Havdalah)
        function deactivateShabbatMode() {
            if (!shabbatMode.active) return;

            console.log('Deactivating Shabbat mode');
            shabbatMode.active = false;
            shabbatMode.activatedAt = null;
            shabbatRandom = null;

            // Clear Shabbat cache
            localStorage.removeItem(SHABBAT_CACHE_KEY_WEATHER);
            localStorage.removeItem(SHABBAT_CACHE_KEY_FORECAST);
            localStorage.removeItem(SHABBAT_CACHE_KEY_QUOTE);
            localStorage.removeItem(SHABBAT_CACHE_KEY_SEED);
            shabbatMode.cachedWeather = null;
            shabbatMode.cachedForecast = null;
            shabbatMode.cachedQuote = null;
            shabbatMode.particleSeed = null;

            // Restart normal particles
            initParticles();

            // Restart update intervals
            shabbatMode.weatherInterval = setInterval(fetchWeather, CACHE_DURATION_WEATHER);
            shabbatMode.forecastInterval = setInterval(fetchForecast, CACHE_DURATION_FORECAST);

            // Fetch fresh data
            fetchWeather();
            fetchForecast();

            // Update quote normally
            updateQuoteDisplay();

            console.log('Shabbat mode deactivated, normal operation resumed');
        }

        // Check if we need to transition in/out of Shabbat mode
        function checkShabbatModeTransition() {
            const shouldBeActive = isRestPeriod();

            if (shouldBeActive && !shabbatMode.active) {
                activateShabbatMode();
            } else if (!shouldBeActive && shabbatMode.active) {
                deactivateShabbatMode();
            }

            // Check if we need to pre-cache (within 6 hours of next rest period)
            if (!shabbatMode.active) {
                const nextRest = getTimeUntilNextRestPeriod();
                if (nextRest && nextRest.hoursUntil <= 6 && nextRest.hoursUntil > 0) {
                    // Pre-cache if we haven't already
                    const cachedWeather = localStorage.getItem(SHABBAT_CACHE_KEY_WEATHER);
                    if (!cachedWeather) {
                        preCacheForShabbat();
                    }
                }
            }
        }

        // Initialize particles for Shabbat mode (deterministic)
        function initParticlesShabbat() {
            if (!shabbatRandom) {
                shabbatRandom = new SeededRandom(shabbatMode.particleSeed || Date.now());
            }

            particles = [];
            const count = 800;
            for (let i = 0; i < count; i++) {
                particles.push(new ParticleShabbat());
            }
        }

        // Shabbat-safe particle class (deterministic, no wind/mouse reactivity)
        class ParticleShabbat {
            constructor() {
                this.reset(true);
            }

            reset(initial = false) {
                const rand = shabbatRandom || { next: () => Math.random() };

                this.depth = 0.3 + rand.next() * 0.7;

                // Fixed direction (45 degrees) - no wind dependency
                const baseAngle = Math.PI / 4;
                const angleVariance = (rand.next() - 0.5) * 0.3;
                this.baseAngle = baseAngle + angleVariance;

                // Fixed speed - no wind dependency
                const baseSpeed = 0.15;
                this.speed = baseSpeed * this.depth * (0.7 + rand.next() * 0.6);
                this.vx = Math.cos(this.baseAngle) * this.speed;
                this.vy = Math.sin(this.baseAngle) * this.speed;

                if (initial) {
                    this.x = rand.next() * W;
                    this.y = rand.next() * H;
                } else {
                    // Spawn from edge opposite to movement direction
                    if (Math.abs(this.vx) > Math.abs(this.vy)) {
                        this.x = this.vx > 0 ? -50 - rand.next() * 50 : W + 50 + rand.next() * 50;
                        this.y = rand.next() * H;
                    } else {
                        this.x = rand.next() * W;
                        this.y = this.vy > 0 ? -50 - rand.next() * 50 : H + 50 + rand.next() * 50;
                    }
                }

                this.size = (0.8 + rand.next() * 2.0) * this.depth;
                this.baseAlpha = (0.12 + rand.next() * 0.2) * this.depth;
                this.alpha = this.baseAlpha;

                this.turbulence = 0.15 + rand.next() * 0.2;
                this.oscPhase = rand.next() * Math.PI * 2;
                this.oscSpeed = 0.001 + rand.next() * 0.002;
                this.oscAmp = 0.08 + rand.next() * 0.12;

                this.trail = [];
                this.maxTrail = 8 + Math.floor(rand.next() * 6);
            }

            update() {
                this.oscPhase += this.oscSpeed;
                noiseTime.t += 0.000001;

                const nx = this.x * noiseScale * 0.3;
                const ny = this.y * noiseScale * 0.3;
                const n = noise2D(nx, ny, noiseTime.t * 5);

                const osc = Math.sin(this.oscPhase) * this.oscAmp;
                const turbAngle = n * Math.PI * this.turbulence + osc;
                const turbVx = Math.cos(this.baseAngle + turbAngle) * this.speed;
                const turbVy = Math.sin(this.baseAngle + turbAngle) * this.speed;

                // NO mouse interaction during Shabbat
                this.vx += (turbVx - this.vx) * 0.008;
                this.vy += (turbVy - this.vy) * 0.008;

                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrail) this.trail.shift();

                this.x += this.vx;
                this.y += this.vy;

                // Fade near edges
                const edgeFade = 80;
                let edgeAlpha = 1;
                if (this.x < edgeFade) edgeAlpha = Math.min(edgeAlpha, this.x / edgeFade);
                if (this.x > W - edgeFade) edgeAlpha = Math.min(edgeAlpha, (W - this.x) / edgeFade);
                if (this.y < edgeFade) edgeAlpha = Math.min(edgeAlpha, this.y / edgeFade);
                if (this.y > H - edgeFade) edgeAlpha = Math.min(edgeAlpha, (H - this.y) / edgeFade);
                this.alpha = this.baseAlpha * Math.max(0, edgeAlpha);

                // Reset when exits screen
                if (this.x < -100 || this.x > W + 100 || this.y < -100 || this.y > H + 100) {
                    this.reset();
                }
            }

            draw() {
                const glow = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 4);
                glow.addColorStop(0, `rgba(255, 255, 255, ${this.alpha})`);
                glow.addColorStop(0.4, `rgba(220, 225, 235, ${this.alpha * 0.4})`);
                glow.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Initialize
        function init() {
            resize();
            initEvents();
            initParticles();

            render();
            fetchWeather();
            fetchForecast();

            // Time display - update every second
            updateTimeDisplay();
            setInterval(updateTimeDisplay, 1000);

            // Hebrew calendar
            updateHebrewCalendar();
            setInterval(updateHebrewCalendar, 60000); // Update every minute

            // Store interval references for Shabbat mode
            shabbatMode.weatherInterval = setInterval(fetchWeather, CACHE_DURATION_WEATHER);
            shabbatMode.forecastInterval = setInterval(fetchForecast, CACHE_DURATION_FORECAST);

            // Check Shabbat mode status every minute
            setInterval(checkShabbatModeTransition, 60000);
            // Initial check
            setTimeout(checkShabbatModeTransition, 5000); // Wait for hebcal to load
        }

        // Expose for testing
        window._lunar = {
            shabbatMode,
            activateShabbatMode,
            deactivateShabbatMode,
            isRestPeriod,
            particles: () => particles
        };

        init();
    })();
    </script>
</body>
</html>
